# -*- coding: utf-8 -*-
"""Translator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X5oJHiRdMwkwWIueEjehnCLNKohNLf9a
"""

import unicodedata
import re
import math
import psutil
import time
import datetime
from io import open
import random
from random import shuffle
import argparse
import numpy as np

import torch
from torch.autograd import Variable
import torch.nn as nn
import torch.nn.functional as F
from torch import optim
import torch.cuda

import pickle

import translator
from translator import *
from translator import Lang

"""this line clears sys to allow for argparse to work as gradient clipper"""
import sys; sys.argv=['']; del sys

def predict (text, direction, cutoff_length=128):
    global input_lang, output_lang, encoder, decoder

    text = request.args['text']
    print("Original Text: ")
    print(text)

    sentences = translator.split_sentences(text)
    predicted_sentences = []
    for sentence in sentences:
        prediction = translator.predict(sentence, encoder, decoder, input_lang, output_lang, "eng", 128)
        predicted_sentences.append(prediction)
    prediction_text = translator.combine_sentences(predicted_sentences, "ina")

    print()
    print("Translated Text: ")
    print(prediction_text)
    return prediction_text

from flask import Flask, request
from flask_cors import CORS
application = Flask('Main App')
CORS(application)

@application.route('/', methods=['GET'])
def get_translation():
    print(request.args)
    source_text = request.args['text']
    translated_text = predict(source_text, 0)
    return translated_text.replace("<EOS>","")

print("Starting")
__name__ = '__main__'
if __name__ == '__main__':
  version = 1
  if version == 1:
    from translator import Lang

    input_lang = pickle.load(open("InterlinguaTranslatorModel_input_lang.pickle", "rb", -1))
    output_lang = pickle.load(open("InterlinguaTranslatorModel_output_lang.pickle", "rb", -1))
    print("Langs ready")


    hidden_size = 720
    layers = 2
    dropout = 0.2
    bidirectional = True

    """create the Encoder"""
    encoder = EncoderRNN(input_lang.vocab_size, hidden_size, layers=layers,
                        dropout=dropout, bidirectional=bidirectional)

    """create the Decoder"""
    decoder = DecoderAttn(hidden_size, output_lang.vocab_size, layers=layers,
                          dropout=dropout, bidirectional=bidirectional)

    print("Creating encoder and decoder")

    encoder.load_state_dict(torch.load("InterlinguaTranslatorModel_enc_weights.pt", map_location=torch.device('cpu')))
    decoder.load_state_dict(torch.load("InterlinguaTranslatorModel_dec_weights.pt", map_location=torch.device('cpu')))

    print("Finished")
